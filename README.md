### Финальное задание 10-го спринта

### Техническое задание
Представьте, что после изучения сложной темы и успешного выполнения всех заданий вы решили отдохнуть и провести вечер за просмотром фильма. Вкусная еда уже готовится, любимый плед и уютное кресло ждут вас — а вы всё ещё не выбрали, что же посмотреть!

Фильмов много — и с каждым годом становится всё больше. Чем их больше, тем больше разных оценок. Чем больше оценок, тем сложнее сделать выбор. Однако не время сдаваться! Вы напишете бэкенд для сервиса, который будет работать с фильмами и оценками пользователей, а также возвращать топ-5 фильмов, рекомендованных к просмотру. Теперь ни вам, ни вашим друзьям не придётся долго размышлять, что посмотреть вечером.

В этом спринте вы начнёте с малого, но очень важного: создадите каркас Spring Boot приложения Filmorate (от англ. film — «фильм» и rate — «оценивать»). В дальнейшем сервис будет обогащаться новым функционалом и с каждым спринтом становиться лучше благодаря вашим знаниям о Java. 


#### Предварительная настройка проекта
В этом модуле вы продолжите работать с финальными проектами по тому же алгоритму, что и раньше:
* Для каждого финального задания спринта создаётся отдельная ветка, в которой оно реализуется.
* После реализации и локальной проверки создаётся Pull Request на слияние изменений текущей ветки задания с основной веткой проекта.
* Перед тем, как будет осуществлено слияние веток — проводится автоматическая проверка в GitHub Actions.
* Если проверка прошла успешно, то ссылку на Pull Request можно отправлять на ревью. Если при проверке были найдены ошибки, то их нужно исправить и провести повторную проверку.

В репозитории уже подготовлено начальное описание сборки в ветке main. Создайте новую ветку controllers-films-users, в ней вы будете выполнять текущее задание. Не забывайте, что репозиторий при этом должен быть публичным.

Теперь можно шаг за шагом реализовать приложение.

#### Модели данных
Создайте пакет model. Добавьте в него два класса: Film и User. Это классы — модели данных приложения.

У model.Film должны быть следующие свойства:
* целочисленный идентификатор — id;
* название — name;
* описание — description;
* дата релиза — releaseDate;
* продолжительность фильма — duration.

Свойства model.User:
* целочисленный идентификатор — id;
* электронная почта — email;
* логин пользователя — login;
* имя для отображения — name;
* дата рождения — birthday.


#### Подсказка: про аннотацию @Data
Используйте аннотацию @Data библиотеки Lombok — с ней будет меньше работы по созданию сущностей.


#### Хранение данных
Сейчас данные можно хранить в памяти приложения — так же, как и в случае с менеджером задач. Для этого используйте контроллер.

В следующих спринтах вы узнаете, как правильно хранить данные в долговременном хранилище, чтобы они не зависели от перезапуска приложения.

#### REST-контроллеры
Создайте два класса-контроллера. FilmController будет обслуживать фильмы, а UserController — пользователей. Убедитесь, что созданные контроллеры соответствуют правилам REST.

Добавьте в классы-контроллеры эндпоинты с подходящим типом запроса для каждого из случаев.

Для FilmController:
* добавление фильма;
* обновление фильма;
* получение всех фильмов.

Для UserController:
* создание пользователя;
* обновление пользователя;
* получение списка всех пользователей.

Эндпоинты для создания и обновления данных должны также вернуть созданную или изменённую сущность.

#### Подсказка: про аннотацию @RequestBody
Используйте аннотацию @RequestBody, чтобы создать объект из тела запроса на добавление или обновление сущности.

#### Валидация
Проверьте данные, которые приходят в запросе на добавление нового фильма или пользователя. Эти данные должны соответствовать определённым критериям. 
Для Film:
* название не может быть пустым;
* максимальная длина описания — 200 символов;
* дата релиза — не раньше 28 декабря 1895 года;
* продолжительность фильма должна быть положительным числом.

Для User:
* электронная почта не может быть пустой и должна содержать символ @;
* логин не может быть пустым и содержать пробелы;
* имя для отображения может быть пустым — в таком случае будет использован логин;
* дата рождения не может быть в будущем.

#### Подсказка: как обработать ошибки
Для обработки ошибок валидации напишите новое исключение — например, ValidationException.

#### Логирование
Добавьте логирование для операций, которые изменяют сущности — добавляют и обновляют их. Также логируйте причины ошибок — например, если валидация не пройдена. Это считается хорошей практикой.

Подсказка: про логирование сообщений

Воспользуйтесь библиотекой slf4j для логирования и объявляйте логер для каждого класса — так будет сразу видно, где в коде выводится та или иная строка.

private final static Logger log = LoggerFactory.getLogger(Example.class);

Вы также можете применить аннотацию @Slf4j библиотеки Lombok, чтобы не создавать логер вручную.

#### Тестирование
Добавьте unit-тесты для валидации моделей. Убедитесь, что она работает на граничных условиях.

#### Подсказка: на что обратить внимание при тестировании
Проверьте, что валидация не пропускает пустые или неверно заполненные поля. Посмотрите, как контроллер реагирует на пустой запрос.

#### Проверьте себя
Так как у вашего API пока нет интерфейса, вы будете взаимодействовать с ним через веб-клиент. Мы подготовили набор тестовых данных — Postman-коллекцию. С её помощью вы сможете протестировать ваш API: postman.json. 
